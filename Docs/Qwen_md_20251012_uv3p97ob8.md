# ðŸ“‹ MenuQR â€“ Resumen TÃ©cnico Completo  
*Ãšltima actualizaciÃ³n: 13 de octubre de 2025*

---

## ðŸŽ¯ Objetivo del Proyecto
MenuQR es una plataforma SaaS para restaurantes que permite:
- Digitalizar cartas fÃ­sicas mediante OCR
- Editar menÃºs visualmente
- Generar QR para pedidos en salÃ³n y delivery
- Gestionar comandas en tiempo real

---

## ðŸ—‚ï¸ Estado del MenÃº: "Esquina Pompeya"

### âœ… Correcciones aplicadas
- Se corrigiÃ³ **â€œRinioncitosâ€ â†’ â€œRiÃ±oncitosâ€**
- Se eliminaron filas con `Precio = nan` (ej: â€œHamburguesa simple / completaâ€, â€œPor confirmarâ€)
- Se unificaron los datos del archivo `Menu_Esquina_Pompeya.md` con los extraÃ­dos de **4 imÃ¡genes reales del menÃº fÃ­sico**
- Resultado: **73 productos vÃ¡lidos** en **9 categorÃ­as completas**

---

## ðŸ” Apartado Especial: Scanner OCR â€“ SoluciÃ³n TÃ©cnica

### âŒ Problema Original
El scanner en `/app/scanner/page.tsx` tenÃ­a:
- PrecisiÃ³n baja (~70%)
- No distinguÃ­a bien entre categorÃ­as, platos y precios
- No integraba los datos extraÃ­dos con el flujo del editor

### âœ… SoluciÃ³n Propuesta
Implementar un **OCR mejorado con post-procesamiento inteligente**, listo para integrar en el **Paso 3 del wizard** (`/editor` o `/editor-clean`).

---

### ðŸ’» CÃ³digo React/TypeScript â€“ Listo para Embeber

> **Archivo sugerido**: `app/components/SmartScanner.tsx`  
> **Dependencias**: `tesseract.js`, `react-dropzone`

```tsx
'use client';

import { useState, useRef } from 'react';
import Tesseract from 'tesseract.js';
import { useDropzone } from 'react-dropzone';

export default function SmartScanner({ onExtracted }: { onExtracted: (data: any[]) => void }) {
  const [isProcessing, setIsProcessing] = useState(false);
  const [preview, setPreview] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const processImage = async (file: File) => {
    if (!file) return;
    
    setIsProcessing(true);
    setPreview(URL.createObjectURL(file));

    try {
      const { data: { text } } = await Tesseract.recognize(file, 'spa', {
        logger: (m) => console.log(m),
      });

      // Post-procesamiento inteligente
      const lines = text
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);

      const extracted = [];
      let currentCategory = 'Sin categorÃ­a';

      for (const line of lines) {
        // Detectar categorÃ­as (mayÃºsculas, sin nÃºmeros)
        if (/^[A-Z\sÃ‘ÃÃ‰ÃÃ“Ãš]+$/.test(line) && !/\d/.test(line)) {
          currentCategory = line;
          continue;
        }

        // Detectar plato + precio (lÃ­nea con nÃºmero al final)
        const priceMatch = line.match(/(.+?)\s*\$?([\d.,]+)$/);
        if (priceMatch) {
          const [, name, priceStr] = priceMatch;
          const price = parseFloat(priceStr.replace(/[.,]/g, ''));
          if (!isNaN(price)) {
            extracted.push({
              category: currentCategory,
              name: name.trim(),
              price: price,
            });
            continue;
          }
        }

        // Si no tiene precio, asumir que es parte de la descripciÃ³n o categorÃ­a
        // (opcional: guardar como "lÃ­nea suelta")
      }

      onExtracted(extracted);
    } catch (error) {
      console.error('Error en OCR:', error);
      alert('Hubo un error al procesar la imagen. Intente con otra foto.');
    } finally {
      setIsProcessing(false);
    }
  };

  const onDrop = (acceptedFiles: File[]) => {
    if (acceptedFiles[0]) processImage(acceptedFiles[0]);
  };

  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: { 'image/*': [] },
    maxFiles: 1,
  });

  return (
    <div className="bg-gray-800 p-6 rounded-lg">
      <h2 className="text-xl font-bold mb-4">ðŸ“¸ Escanear Carta FÃ­sica</h2>
      
      <div
        {...getRootProps()}
        className="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:bg-gray-700"
      >
        <input {...getInputProps()} />
        {isProcessing ? (
          <p>Procesando... ðŸ§ </p>
        ) : (
          <p>Arrastra una foto de tu carta o haz clic para subirla</p>
        )}
      </div>

      {preview && (
        <div className="mt-4">
          <p className="text-sm text-gray-400">Vista previa:</p>
          <img src={preview} alt="Preview" className="mt-2 max-h-64 object-contain rounded" />
        </div>
      )}

      <button
        onClick={() => fileInputRef.current?.click()}
        className="mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
      >
        Usar CÃ¡mara
      </button>
      <input
        ref={fileInputRef}
        type="file"
        capture="environment"
        accept="image/*"
        className="hidden"
        onChange={(e) => e.target.files?.[0] && processImage(e.target.files[0])}
      />
    </div>
  );
}