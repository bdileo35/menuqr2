# 📋 MenuQR – Resumen Técnico Completo  
*Última actualización: 13 de octubre de 2025*

---

## 🎯 Objetivo del Proyecto
MenuQR es una plataforma SaaS para restaurantes que permite:
- Digitalizar cartas físicas mediante OCR
- Editar menús visualmente
- Generar QR para pedidos en salón y delivery
- Gestionar comandas en tiempo real

---

## 🗂️ Estado del Menú: "Esquina Pompeya"

### ✅ Correcciones aplicadas
- Se corrigió **“Rinioncitos” → “Riñoncitos”**
- Se eliminaron filas con `Precio = nan` (ej: “Hamburguesa simple / completa”, “Por confirmar”)
- Se unificaron los datos del archivo `Menu_Esquina_Pompeya.md` con los extraídos de **4 imágenes reales del menú físico**
- Resultado: **73 productos válidos** en **9 categorías completas**

---

## 🔍 Apartado Especial: Scanner OCR – Solución Técnica

### ❌ Problema Original
El scanner en `/app/scanner/page.tsx` tenía:
- Precisión baja (~70%)
- No distinguía bien entre categorías, platos y precios
- No integraba los datos extraídos con el flujo del editor

### ✅ Solución Propuesta
Implementar un **OCR mejorado con post-procesamiento inteligente**, listo para integrar en el **Paso 3 del wizard** (`/editor` o `/editor-clean`).

---

### 💻 Código React/TypeScript – Listo para Embeber

> **Archivo sugerido**: `app/components/SmartScanner.tsx`  
> **Dependencias**: `tesseract.js`, `react-dropzone`

```tsx
'use client';

import { useState, useRef } from 'react';
import Tesseract from 'tesseract.js';
import { useDropzone } from 'react-dropzone';

export default function SmartScanner({ onExtracted }: { onExtracted: (data: any[]) => void }) {
  const [isProcessing, setIsProcessing] = useState(false);
  const [preview, setPreview] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const processImage = async (file: File) => {
    if (!file) return;
    
    setIsProcessing(true);
    setPreview(URL.createObjectURL(file));

    try {
      const { data: { text } } = await Tesseract.recognize(file, 'spa', {
        logger: (m) => console.log(m),
      });

      // Post-procesamiento inteligente
      const lines = text
        .split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 0);

      const extracted = [];
      let currentCategory = 'Sin categoría';

      for (const line of lines) {
        // Detectar categorías (mayúsculas, sin números)
        if (/^[A-Z\sÑÁÉÍÓÚ]+$/.test(line) && !/\d/.test(line)) {
          currentCategory = line;
          continue;
        }

        // Detectar plato + precio (línea con número al final)
        const priceMatch = line.match(/(.+?)\s*\$?([\d.,]+)$/);
        if (priceMatch) {
          const [, name, priceStr] = priceMatch;
          const price = parseFloat(priceStr.replace(/[.,]/g, ''));
          if (!isNaN(price)) {
            extracted.push({
              category: currentCategory,
              name: name.trim(),
              price: price,
            });
            continue;
          }
        }

        // Si no tiene precio, asumir que es parte de la descripción o categoría
        // (opcional: guardar como "línea suelta")
      }

      onExtracted(extracted);
    } catch (error) {
      console.error('Error en OCR:', error);
      alert('Hubo un error al procesar la imagen. Intente con otra foto.');
    } finally {
      setIsProcessing(false);
    }
  };

  const onDrop = (acceptedFiles: File[]) => {
    if (acceptedFiles[0]) processImage(acceptedFiles[0]);
  };

  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: { 'image/*': [] },
    maxFiles: 1,
  });

  return (
    <div className="bg-gray-800 p-6 rounded-lg">
      <h2 className="text-xl font-bold mb-4">📸 Escanear Carta Física</h2>
      
      <div
        {...getRootProps()}
        className="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center cursor-pointer hover:bg-gray-700"
      >
        <input {...getInputProps()} />
        {isProcessing ? (
          <p>Procesando... 🧠</p>
        ) : (
          <p>Arrastra una foto de tu carta o haz clic para subirla</p>
        )}
      </div>

      {preview && (
        <div className="mt-4">
          <p className="text-sm text-gray-400">Vista previa:</p>
          <img src={preview} alt="Preview" className="mt-2 max-h-64 object-contain rounded" />
        </div>
      )}

      <button
        onClick={() => fileInputRef.current?.click()}
        className="mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
      >
        Usar Cámara
      </button>
      <input
        ref={fileInputRef}
        type="file"
        capture="environment"
        accept="image/*"
        className="hidden"
        onChange={(e) => e.target.files?.[0] && processImage(e.target.files[0])}
      />
    </div>
  );
}